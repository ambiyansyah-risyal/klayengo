#!/bin/bash

# Optimized pre-commit hook with parallel execution and smart CI detection
# Performance improvements:
# - Parallel execution of independent checks
# - Incremental linting on changed files only
# - Smart CI file detection and caching
# - Early exit on critical failures

set -e

# Configuration
MAX_PARALLEL_JOBS=4
TEMP_DIR="/tmp/klayengo-precommit-$$"
LOG_FILE="${TEMP_DIR}/precommit.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Cleanup function
cleanup() {
    rm -rf "${TEMP_DIR}"
}
trap cleanup EXIT

# Create temp directory
mkdir -p "${TEMP_DIR}"

# Performance timing
start_time=$(date +%s.%N)

echo -e "${YELLOW}üöÄ Running optimized pre-commit checks...${NC}"

# Get list of changed files for incremental checking
CHANGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)
GO_FILES=$(echo "${CHANGED_FILES}" | grep '\.go$' || true)
ALL_FILES_COUNT=$(echo "${CHANGED_FILES}" | wc -l)

echo "üìÅ Changed files: ${ALL_FILES_COUNT}"
if [ -n "${GO_FILES}" ]; then
    GO_FILES_COUNT=$(echo "${GO_FILES}" | wc -l)
    echo "üêπ Go files: ${GO_FILES_COUNT}"
fi

# Smart CI detection - check if any CI-related files changed
CI_FILES=$(echo "${CHANGED_FILES}" | grep -E '\.(yml|yaml)$|^\.github/|Makefile|go\.mod|go\.sum' || true)
RUN_FULL_CI=false
if [ -n "${CI_FILES}" ]; then
    echo "üîß CI files changed, running full CI pipeline"
    RUN_FULL_CI=true
fi

# Function to run a check in background
run_check() {
    local name="$1"
    local command="$2"
    local output_file="${TEMP_DIR}/${name}.out"
    local start_check_time=$(date +%s.%N)
    
    echo "‚ñ∂Ô∏è  Starting ${name}..." | tee -a "${LOG_FILE}"
    
    if eval "${command}" > "${output_file}" 2>&1; then
        local end_check_time=$(date +%s.%N)
        local duration=$(echo "${end_check_time} - ${start_check_time}" | bc -l)
        printf "‚úÖ %-20s (%.2fs)\n" "${name}" "${duration}" | tee -a "${LOG_FILE}"
        echo "0" > "${TEMP_DIR}/${name}.status"
    else
        local end_check_time=$(date +%s.%N)
        local duration=$(echo "${end_check_time} - ${start_check_time}" | bc -l)
        printf "‚ùå %-20s (%.2fs)\n" "${name}" "${duration}" | tee -a "${LOG_FILE}"
        echo "1" > "${TEMP_DIR}/${name}.status"
        
        # Show error output
        echo -e "\n${RED}Error output for ${name}:${NC}" | tee -a "${LOG_FILE}"
        cat "${output_file}" | tee -a "${LOG_FILE}"
    fi
}

# Parallel job management
job_pids=()
active_jobs=0

# Function to wait for job slot
wait_for_slot() {
    while [ ${active_jobs} -ge ${MAX_PARALLEL_JOBS} ]; do
        for i in "${!job_pids[@]}"; do
            if ! kill -0 "${job_pids[$i]}" 2>/dev/null; then
                unset job_pids[$i]
                ((active_jobs--))
                break
            fi
        done
        sleep 0.1
    done
}

# Function to start a background job
start_job() {
    local name="$1"
    local command="$2"
    
    wait_for_slot
    run_check "${name}" "${command}" &
    job_pids+=($!)
    ((active_jobs++))
}

# 1. Format check (fast, run first)
if [ -n "${GO_FILES}" ]; then
    start_job "format_check" "gofmt -l ${GO_FILES} | wc -l | grep -q '^0$'"
fi

# 2. Incremental linting (only on changed Go files)
if [ -n "${GO_FILES}" ]; then
    if command -v golangci-lint >/dev/null 2>&1; then
        # Create temporary golangci-lint config for incremental mode
        TEMP_CONFIG="${TEMP_DIR}/.golangci.yml"
        cat > "${TEMP_CONFIG}" << 'EOF'
run:
  timeout: 5m
  modules-download-mode: readonly
  
linters:
  enable-all: false
  enable:
    - errcheck
    - gosimple
    - govet
    - ineffassign
    - staticcheck
    - typecheck
    - unused
    - misspell
    - gofmt
    - goimports

linters-settings:
  errcheck:
    check-type-assertions: true
  govet:
    check-shadowing: false
  misspell:
    locale: US

issues:
  max-issues-per-linter: 50
  max-same-issues: 10
EOF
        
        # Build file list for golangci-lint
        GO_FILE_LIST="${TEMP_DIR}/go_files.txt"
        echo "${GO_FILES}" > "${GO_FILE_LIST}"
        
        start_job "lint_incremental" "golangci-lint run --config='${TEMP_CONFIG}' --new-from-rev=HEAD~1 --out-format=colored-line-number"
    else
        start_job "vet_check" "go vet ${GO_FILES}"
    fi
fi

# 3. Build check (essential for correctness)
start_job "build_check" "go build -v ./..."

# 4. Unit tests (fast tests only, skip integration tests)
start_job "unit_tests" "go test -short -race ./..."

# 5. Module verification
start_job "mod_verify" "go mod verify"

# 6. Full CI pipeline (only if CI files changed or forced)
if [ "${RUN_FULL_CI}" = true ]; then
    if command -v act >/dev/null 2>&1; then
        # Check if act is available and docker is running
        if docker info >/dev/null 2>&1; then
            start_job "ci_pipeline" "act --job test --quiet"
        else
            echo "‚ö†Ô∏è  Docker not available, skipping act CI pipeline"
        fi
    else
        echo "‚ö†Ô∏è  act not installed, skipping local CI simulation"
    fi
fi

# Wait for all jobs to complete
echo ""
echo "‚è≥ Waiting for all checks to complete..."

for pid in "${job_pids[@]}"; do
    if [ -n "${pid}" ]; then
        wait "${pid}" 2>/dev/null || true
    fi
done

# Collect results
total_checks=0
failed_checks=0
failed_check_names=()

echo ""
echo "üìä Check Results:"
echo "=================="

for status_file in "${TEMP_DIR}"/*.status; do
    if [ -f "${status_file}" ]; then
        check_name=$(basename "${status_file}" .status)
        status=$(cat "${status_file}")
        ((total_checks++))
        
        if [ "${status}" = "0" ]; then
            echo -e "‚úÖ ${check_name}"
        else
            echo -e "‚ùå ${check_name}"
            ((failed_checks++))
            failed_check_names+=("${check_name}")
        fi
    fi
done

# Performance summary
end_time=$(date +%s.%N)
total_duration=$(echo "${end_time} - ${start_time}" | bc -l)

echo ""
echo "‚è±Ô∏è  Performance Summary:"
echo "======================="
printf "Total duration: %.2fs\n" "${total_duration}"
echo "Parallel jobs: ${MAX_PARALLEL_JOBS}"
echo "Checks run: ${total_checks}"

# Final result
echo ""
if [ ${failed_checks} -eq 0 ]; then
    echo -e "${GREEN}‚úÖ All pre-commit checks passed! (${total_checks}/${total_checks})${NC}"
    printf "${GREEN}üöÄ Optimized workflow completed in %.2fs${NC}\n" "${total_duration}"
    exit 0
else
    echo -e "${RED}‚ùå ${failed_checks}/${total_checks} checks failed:${NC}"
    for failed_check in "${failed_check_names[@]}"; do
        echo -e "  ${RED}‚Ä¢ ${failed_check}${NC}"
    done
    echo ""
    echo -e "${RED}üõë Commit aborted. Please fix the issues above.${NC}"
    echo ""
    echo "üí° Tips:"
    echo "   ‚Ä¢ Run 'gofmt -w .' to fix formatting issues"
    echo "   ‚Ä¢ Run 'golangci-lint run' to see detailed linting issues"  
    echo "   ‚Ä¢ Run 'go test ./...' to see test failures"
    echo "   ‚Ä¢ Use 'git commit --no-verify' to skip hooks (not recommended)"
    
    exit 1
fi